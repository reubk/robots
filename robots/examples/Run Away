; Robot Name:  RunAway;;  Tries to stay away from other robots by finding the largest gap between;  robots that it can dodge through.;;  An improvement would be to know about walls and try to keep from getting;  cornered by dodging into the open to a far corner, even if it means moving;  closer to a robot in order to squeeze by it.CPU_SPEED 2ARMOR 0FIRE_RATE 0ENGINE_SIZE 0RADAR_RANGE 2CLOAKING 1FUEL_CAPACITY 1define kCLOSE_SEARCH_INCREMENT 3define true 1define false 0allocate closestRobotDistanceallocate closestRobotAngleallocate beginGapWithNoRobotsallocate centerOfGapWithNoRobotsallocate largestCurrentGapWithNoRobotsallocate currentGapSizeallocate oldDamageallocate totalAngleSearchedallocate searchIncrementallocate endAngle    0 to oldDamage    0 to direction    0 to cloak    20 to speed    TimeInterrupt to time_int_xfer    1 to time_int_maskrepeat    0 to aim    0 to beginGapWithNoRobots    0 to largestCurrentGapWithNoRobots    0 to centerOfGapWithNoRobots    0 to currentGapSize    0 to totalAngleSearched    9999 to closestRobotDistance     ;Start by finding first robot to begin looking for first gap.    repeat        aim to radar        aim + searchIncrement to aim    until radar > 0    aim to endAngle    radar to closestRobotDistance    aim to closestRobotAngle    repeat        aim + searchIncrement to aim to radar        if radar > 0 then  ; Found another robot, see if it is the closest one so far.             if shot = 0 then radar to shot             if radar < closestRobotDistance then                  radar to closestRobotDistance                  aim to closestRobotAngle              end                 ;Don't worry about robots over 250 pixels away when looking for gaps.              if radar < 250 then                  trace                  if currentGapSize > largestCurrentGapWithNoRobots then                         ; A big improvement here would be to disregard gaps that would                         ; force us too close to a wall.  Right now we can get cornered by                         ; robots because we run away to the biggest gap which may be towards                         ; a wall.                      currentGapSize to largestCurrentGapWithNoRobots                         ; note the gap and start off in that direction while we search for a bigger gap                      0 - largestCurrentGapWithNoRobots/2 + aim to centerOfGapWithNoRobots                      if currentGapSize > 120 then centerOfGapWithNoRobots to direction                  end                  0 to currentGapSize              end        else  ;Don't see a robot, so the gap grows.            currentGapSize + searchIncrement to currentGapSize            totalAngleSearched + searchIncrement to totalAngleSearched        end        ;Did a 360 so        if endAngle-searchIncrement mod 360 < aim then   ; if endAngle - searchIncrement < aim <= endAngle            if aim <= endAngle then                 trace                if currentGapSize > largestCurrentGapWithNoRobots then                       ; A big improvement here would be to disregard gaps that would                       ; force us too close to a wall.  Right now we can get cornered by                       ; robots because we run away to the biggest gap which may be towards                       ; a wall.                    currentGapSize to largestCurrentGapWithNoRobots                       ; note the gap and start off in that direction while we search for a bigger gap                    0 - largestCurrentGapWithNoRobots/2 + aim to centerOfGapWithNoRobots                    if currentGapSize > 120 then centerOfGapWithNoRobots to direction                end            end        end    until totalAngleSearched > 360  ;Search 1 loop then reset variables    centerOfGapWithNoRobots to direction    if closestRobotDistance < 150 then        20 to speed    else        10 to speed    enduntil true = falsedefine kTURN_RATE 90define SAFETY_DIST 40AdjustDirection    if direction < 180 then  ;Check right wall        if XMAX-SAFETY_DIST < x then direction + kTURN_RATE to direction    else        ;Check left wall        if x < SAFETY_DIST then direction + kTURN_RATE to direction    end    if direction < 90 then  ;Check top wall        if y < SAFETY_DIST then direction + kTURN_RATE to direction    else        if direction > 270 then  ;Check top wall            if y < SAFETY_DIST then direction + kTURN_RATE to direction        else    ; Check bottom wall because  90 < direction < 270            if YMAX-SAFETY_DIST < y then direction + kTURN_RATE to direction        end    endreturn    TimeInterrupt    num_Robots to searchIncrement    gosub AdjustDirection    if cloak > 0 then cloak - 1 to cloak    if damage <> oldDamage then        5 to cloak        damage to oldDamage    endendint    